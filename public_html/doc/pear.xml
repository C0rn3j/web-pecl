<?xml version='1.0' encoding='ISO-8859-1' ?>
<!DOCTYPE article PUBLIC "-//Norman Walsh//DTD DocBk XML V1.7//EN"
          "/home/ssb/cvs/php/phpdoc/dbxml/docbookx.dtd">
<article id="pear">
 <artheader>
  <title>PEAR: PHP Extension and Add-on Repository</title>
  <authorgroup>
   <author>
    <firstname>Stig</firstname>
    <surname>Bakken</surname>
   </author>
  </authorgroup>
  <releaseinfo>
   <comment>
    This document is incomplete.  For now it only contains a brief
    description of PEAR and "Coding Rules and Guidelines".  The rules
    and guidelines are initial suggestions, and are open for
    discussion.
   </comment>
  </releaseinfo>
  <revhistory>
   <revision>
    <revnumber>$Revision: 1.5 $</revnumber>
    <date>$Date: 2000-07-17 22:54:39 $</date>
    <authorinitials>$Author: ssb $</authorinitials>
   </revision>
  </revhistory>
 </artheader>
 
 <simpara>PEAR is dedicated to Malin Bakken, born 1999-11-21.</simpara>

 <section id="pear-whatis">
  <title>What is PEAR?</title>
  <simpara>
   PEAR is a code repository for PHP extensions and PHP library code
   inspired by TeX's CTAN and Perl's CPAN.
  </simpara>
  <simpara>
   The intention behind PEAR is to provide a means for library code
   authors to share their code with other developers, to give the PHP
   community an infrastructure for using third-party code, to define
   standards that help developers write code that runs in different
   PHP configurations, and to provide tools for code maintenance and
   distribution.
  </simpara>

 </section>

 <section id="pear-rules">
  <title>Coding Rules and Guidelines</title>
  <simpara>
   This section describes some rules that are meant to make PEAR code
   available to as many users as possible.  If you want to contribute
   to PEAR, please read this section carefully and follow these rules,
   or someone will yell at you. :-)
  </simpara>

  <section id="pear-names">
   <title>Naming Conventions</title>

   <para>
    Use the extension <filename role="extension">.php</filename> for
    all files with PHP code.
    <note>
     <simpara>
      It is important that your files do not output anything, so watch
      those linefeeds at the end of files (no more than one!)
     </simpara>
    </note>
   </para>

   <para>
    A related set of one or more classes and functions in PEAR are
    called packages.  Not modules, since this term is already taken by
    Apache, and not extensions, because that is what PHP's bundled
    "modules" of C code are called.  "Packages" it is.
   </para>

   <para>
    The main structure in PEAR is the package structure.  Although
    this structure maps 1:1 down to the file system, it is
    conceptually not a filesystem structure.  The structure is based
    on the developer's view when writing code, which is the parameters
    to <function role="statement">use</function>.  An example:
    <informalexample>
     <literallayout>DB
    DB/common
    DB/mysql
HTML
    HTML/Form
</literallayout>
    </informalexample>
    Here, the names listed are the parameters the user will give the
    "use" or "import" PHP statements.  It maps down to the filesystem
    level by adding <filename role="extension">.php</filename>.  This
    means that each "top-level" node will have both a file and a
    directory in the top-level directory.  But we have an excuse for
    this: the PEAR structure is conceptually different from the
    filesystem structure, as explained above.  So there.
   </para>

   <section id="pear-pkgnames">
    <title>Package Names</title>
    <simpara>
     The definition of a package in PEAR is file defining one "public"
     class and possible several "private" ones.  Although PHP doesn't
     have the notion of public classes, PEAR uses this concept.  A
     public class is a class that is available to other packages or
     the user, a private class is a class that is internal to that
     package, and that the PHP programmer will normally not deal with
     directly.
    </simpara>
    <simpara>
     All PEAR package files should use the suffix <filename
     role="suffix">.php</filename>.  The class name is the file name
     without the <filename role="suffix">.php</filename> suffix.
    </simpara>
    <para>
     For example, the package <systemitem
     role="package">DB/mysql</systemitem> would have its code in a
     file called <filename>mysql.php</filename> in a directory called
     <filename>DB</filename> in a directory in PHP's include path.
    </para>
   </section>

   <section id="pear-classnames">
    <title>Class Names</title>
    <para>
     PEAR classes should never have name conflicts.  Since PHP doesn't
     have packages or name spaces yet, it is necessary to enforce a
     class naming convention that provides a "poor man's name spaces".
     Hopefully this will serve as an inspiration for the Zend authors
     to implement name spaces :-).
    </para>
    <para>
     The basic class name rule is to use the package name and
     substitute slashes with underscores.  The package <systemitem
     role="package">DB/mysql</systemitem> has its code in the file
     <filename>DB/mysql.php</filename> and defines a class called
     <classname>DB_mysql</classname>.
    </para>
   </section>

   <section id="pear-functions">
    <title>Functions</title>
    <simpara>
     At this time, PEAR does not support plain functions.  The reason
     for this is that we want to avoid name space problems where
     different packages define functions with the same name.  One
     solution could be prefixing each function's name with its package
     name, but then encapsulating the functions in classes is better.
    </simpara>
    <simpara>
     When PHP gets support for namespaces (some time _after_ the 4.0
     release), PEAR will support plain functions.
    </simpara>
    <para>
     If you have a function you want to make available in a PEAR
     package, make a class based on the package name (Foo/Bar -&gt;
     Foo_Bar), and add the function as a method there.  Example:
     <informalexample>
      <programlisting>
Header("Last-Modified: " . HTTP::Date(getlastmod()));
</programlisting>
     </informalexample>
    </para>
   </section>

   <section id="pear-funcnames">
    <title>Method Names</title>
    <simpara>
     Methods should be named with initial lower-case studlycaps like
     this: <function>myFunction</function>.
    </simpara>
   </section>
  </section>

  <section>
   <title>Variable Names</title>
   <simpara>
    Global variables visible to the user should be prefixed with the
    package name with "/" substituted with "_" (like for class names)
    and an underscore.  If you need global variables that are not to
    be "visible" to the user, prefix the whole thing with an
    underscore.
   </simpara>
   <para>
    Example (let's say this package is Gah/Zonk):
    <informalexample>
     <programlisting>
&lt?php

$Gah_Zonk_errorcodes = array( -1 => "This error",
                              -2 => "That error" );
$_Gah_Zonk_cache = array();

?>
</programlisting>
    </informalexample>
   </para>
  </section>

  <section id="pear-errors">
   <title>Errors</title>
   <simpara>
    Never use <function>exit</function> or <function>die</function> if
    your PEAR package encounters an error.  Doing this generally makes
    peoples lives miserable when they try handling errors nicely.  Try
    to always provide a way of telling whether something went wrong
    and what, be it as simple as returning an error code, or something
    more fancy.
   </simpara>
  </section>

  <section id="pear-options">
   <title>Optional PHP Features</title>
   <simpara>
    PEAR code should be useable with all (reasonable) configurations
    of PHP.  Since PHP is very configurable and many of its features
    are optional, this requires extra attention from you as a PEAR
    author to make sure that your code works with different
    configurations.
   </simpara>
   <para>
    One example is the <parameter>magic_quotes_gpc</parameter> config
    option.  PEAR code should work with this option enabled or
    disabled.  Here's an example of how to properly do that:
    <informalexample>
     <programlisting role="php">
// If magic_quotes_gpc is enabled, remove those slashes.
if (ini_get("magic_quotes_gpc")) {
    $arg = stripslashes($arg);
}
</programlisting>
    </informalexample>
   </para>

   <section id="pear-phptags">
    <title>PHP Code Block Tags</title>
    <simpara>
     Always use the <command>&lt;?php ?&gt;</command> syntax, the
     shorter forms such as <command>&lt;? ?&gt;</command> and
     <command>&lt;% %&gt;</command> may be disabled by the user.
    </simpara>
   </section>

   <section id="pear-gpcvars">
    <title>HTTP_*_VARS</title>
    <simpara>
     GET/POST/cookie can be configured to not be set in the global
     namespace, so PEAR code reading these should always use the
     global arrays <varname>$HTTP_GET_VARS</varname>,
     <varname>$HTTP_POST_VARS</varname>,
     <varname>$HTTP_COOKIE_VARS</varname>,
     <varname>$HTTP_SERVER_VARS</varname>,
     <varname>$HTTP_ENV_VARS</varname> and
     <varname>$HTTP_POST_FILES</varname> rather than the global
     variables.
    </simpara>
   </section>

   <section id="pear-scope">
    <title>Scope Issues</title>
    <simpara>
     If you need to set some global variables in the top-level part of
     your code (outside classes and functions), it is necessary to use
     <varname>$GLOBALS</varname> to make sure your variable is
     actually set in the global scope regardless of where your file is
     included from.
    </simpara>

    <para>
     It is possible, and often very useful, to include a file from
     within a function.  The included file will inherit the calling
     code's scope:

     <example>
      <title>file1.php</title>
      <programlisting role="html">
&lt;?php $myglobal = 42; ?&gt;
</programlisting>
     </example>

     <example>
      <title>file2.php</title>
      <programlisting role="html">
&lt;?php

class Foo {
    function Foo($arg) {
        if ($arg == 42) {
            include("file1.php");
        }
    }
}

?&gt;
</programlisting>
     </example>
    </para>

    <simpara>
     This actually sets <varname>$myglobal</varname> as a local
     variable in the <classname>Foo</classname> class's constructor
     function, not as a global variable.
    </simpara>
    
   </section>

  </section>

 </section>

</article>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-set-face:t
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
sgml-default-dtd-file:"article.ced"
sgml-auto-insert-required-elements:nil
End:
-->
