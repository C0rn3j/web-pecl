<HTML
><HEAD
><TITLE
>PEAR: PHP Extension and Application Repository</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.52"><META
NAME="HTTP_EQUIV"
CONTENT="text/html; charset=ISO-8859-1"></HEAD
><BODY
CLASS="article"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"
>PEAR: PHP Extension and Application Repository</A
></H1
><DIV
CLASS="authorgroup"
><A
NAME="AEN4"
></A
><H3
CLASS="author"
><A
NAME="AEN5"
>Stig Bakken</A
></H3
></DIV
><SPAN
CLASS="releaseinfo"
>&#13;   
  <BR></SPAN
><DIV
CLASS="revhistory"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision $Revision$</TD
><TD
ALIGN="LEFT"
>$Date$</TD
><TD
ALIGN="LEFT"
>Revised by: $Author$</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
></TD
></TR
></TABLE
></DIV
><HR></DIV
><P
>PEAR is dedicated to <A
HREF="http://www.pvv.org/~ssb/malin/bilder/mi/twain001.jpg"
TARGET="_top"
>Malin Bakken</A
>, born
  1999-11-21.</P
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="pear-whatis"
>What is PEAR?</A
></H1
><P
>&#13;   PEAR is a code repository for PHP extensions and PHP library code
   inspired by TeX's CTAN and Perl's CPAN.
  </P
><P
>&#13;   The intention behind PEAR is to provide a means for library code
   authors to share their code with other developers, to give the PHP
   community an infrastructure for using third-party code, to define
   standards that help developers write code that runs in different
   PHP configurations, and to provide tools for code maintenance and
   distribution.
  </P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="pear-rules"
>Coding Rules and Guidelines</A
></H1
><P
>&#13;   This section describes some rules that are meant to make PEAR code
   available to as many users as possible.  If you want to contribute
   to PEAR, please read this section carefully and follow these rules,
   or someone will yell at you. :-)
  </P
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="pear-names"
>Naming Conventions</A
></H2
><P
>&#13;    Use the extension <TT
CLASS="filename"
>.php</TT
> for
    all files with PHP code.
    <DIV
CLASS="note"
><BLOCKQUOTE
CLASS="note"
><P
><B
>Note: </B
>
      It is important that your files do not output anything, so watch
      those linefeeds at the end of files (no more than one!)
     </P
></BLOCKQUOTE
></DIV
>
   </P
><P
>&#13;    A related set of one or more classes and functions in PEAR are
    called packages.  Not modules, since this term is already taken by
    Apache, and not extensions, because that is what PHP's bundled
    "modules" of C code are called.  "Packages" it is.
   </P
><P
>&#13;    The main structure in PEAR is the package structure.  Although
    this structure maps 1:1 down to the file system, it is
    conceptually not a filesystem structure.  The structure is based
    on the developer's view when writing code, which is the parameters
    to <B
CLASS="function"
>use</B
>.  An example:
    <DIV
CLASS="informalexample"
><P
></P
><P
CLASS="literallayout"
>DB<br>
&nbsp;&nbsp;&nbsp;&nbsp;DB/common<br>
&nbsp;&nbsp;&nbsp;&nbsp;DB/mysql<br>
HTML<br>
&nbsp;&nbsp;&nbsp;&nbsp;HTML/Form<br>
</P
><P
></P
></DIV
>
    Here, the names listed are the parameters the user will give the
    "use" or "import" PHP statements.  It maps down to the filesystem
    level by adding <TT
CLASS="filename"
>.php</TT
>.  This
    means that each "top-level" node will have both a file and a
    directory in the top-level directory.  But we have an excuse for
    this: the PEAR structure is conceptually different from the
    filesystem structure, as explained above.  So there.
   </P
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="pear-pkgnames"
>Package Names</A
></H3
><P
>&#13;     The definition of a package in PEAR is file defining one "public"
     class and possible several "private" ones.  Although PHP doesn't
     have the notion of public classes, PEAR uses this concept.  A
     public class is a class that is available to other packages or
     the user, a private class is a class that is internal to that
     package, and that the PHP programmer will normally not deal with
     directly.
    </P
><P
>&#13;     All PEAR package files should use the suffix <TT
CLASS="filename"
>.php</TT
>.  The class name is the file name
     without the <TT
CLASS="filename"
>.php</TT
> suffix.
    </P
><P
>&#13;     For example, the package <SPAN
CLASS="systemitem"
>DB/mysql</SPAN
> would have its code in a
     file called <TT
CLASS="filename"
>mysql.php</TT
> in a directory called
     <TT
CLASS="filename"
>DB</TT
> in a directory in PHP's include path.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="pear-classnames"
>Class Names</A
></H3
><P
>&#13;     PEAR classes should never have name conflicts.  Since PHP doesn't
     have packages or name spaces yet, it is necessary to enforce a
     class naming convention that provides a "poor man's name spaces".
     Hopefully this will serve as an inspiration for the Zend authors
     to implement name spaces :-).
    </P
><P
>&#13;     The basic class name rule is to use the package name and
     substitute slashes with underscores.  The package <SPAN
CLASS="systemitem"
>DB/mysql</SPAN
> has its code in the file
     <TT
CLASS="filename"
>DB/mysql.php</TT
> and defines a class called
     <TT
CLASS="classname"
>DB_mysql</TT
>.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="pear-functions"
>Functions</A
></H3
><P
>&#13;     At this time, PEAR does not support plain functions.  The reason
     for this is that we want to avoid name space problems where
     different packages define functions with the same name.  One
     solution could be prefixing each function's name with its package
     name, but then encapsulating the functions in classes is better.
    </P
><P
>&#13;     When PHP gets support for namespaces (some time _after_ the 4.0
     release), PEAR will support plain functions.
    </P
><P
>&#13;     If you have a function you want to make available in a PEAR
     package, make a class based on the package name (Foo/Bar -&#62;
     Foo_Bar), and add the function as a method there.  Example:
     <DIV
CLASS="informalexample"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;Header("Last-Modified: " . HTTP::Date(getlastmod()));
</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="pear-funcnames"
>Method Names</A
></H3
><P
>&#13;     Methods should be named with initial lower-case studlycaps like
     this: <B
CLASS="function"
>myFunction()</B
>.
    </P
></DIV
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="pear-variables"
>Variable Names</A
></H2
><P
>&#13;    Global variables visible to the user should be prefixed with the
    package name with "/" substituted with "_" (like for class names)
    and an underscore.  If you need global variables that are not to
    be "visible" to the user, prefix the whole thing with an
    underscore.
   </P
><P
>&#13;    Example (let's say this package is Gah/Zonk):
    <DIV
CLASS="informalexample"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;&#60;?php

$Gah_Zonk_errorcodes = array( -1 =&#62; "This error",
                              -2 =&#62; "That error" );
$_Gah_Zonk_cache = array();

?&#62;
</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="pear-errors"
>Errors</A
></H2
><P
>&#13;    Never use <B
CLASS="function"
>exit()</B
> or <B
CLASS="function"
>die()</B
> if
    your PEAR package encounters an error.  Doing this generally makes
    peoples lives miserable when they try handling errors nicely.  Try
    to always provide a way of telling whether something went wrong
    and what, be it as simple as returning an error code, or something
    more fancy.
   </P
><P
>&#13;    Fortunately, PEAR a general mechanism for reporting errors.  An
    error is "raised" by creating an error object that may be used as
    the return value of a function/method.  I say "may be used"
    because PEAR errors have several modes of operation: simply
    returning an object with more information, printing the error (and
    optionally exit), call PHP's internal error handling functions, or
    invoke a callback function.
   </P
><P
>&#13;    Use the PEAR::isError() function to determine whether a returned
    value is a PEAR error.
   </P
><P
>&#13;    The following example makes an error wrapper around PHP's built-in
    <B
CLASS="function"
>fsockopen()</B
> function following PEAR
    conventions.
    <TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
CLASS="EXAMPLE"
><TR
><TD
><DIV
CLASS="example"
><P
><B
>Example 1. PEAR error example 1</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;&#60;?php

// PEAR_Error is defined in PEAR.php
require_once 'PEAR.php';

function myfsockopen($host, $port) {
    $fp = @fsockopen($host, $port, &#38;$errno, &#38;$errstr, 10);
    if (!$fp) {
        return new PEAR_Error($errstr, $errno, PEAR_ERROR_RETURN, null,
                              "$host:$port");
    }
    return $fp;
}

$sock = myfsockopen("www.php.net", 80);
if (PEAR::isError($sock)) {
    print "&#60;B&#62;Error: ".$sock-&#62;getMessage()."&#60;/B&#62;\n";
}

?&#62;
</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
   </P
><P
>&#13;    You can customize the error handling by subclassing
    <TT
CLASS="classname"
>PEAR_Error</TT
> and adding your own stuff on top
    of that, <B
CLASS="function"
>PEAR::isError()</B
> will return true for
    any object that is an instance of
    <TT
CLASS="classname"
>PEAR_Error</TT
> or a class inheriting it.
   </P
><P
>&#13;    Some PEAR classes already do this, such as the DB error class,
    <TT
CLASS="classname"
>DB_Error</TT
>:
    <TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
CLASS="EXAMPLE"
><TR
><TD
><DIV
CLASS="example"
><P
><B
>Example 2. DB_Error example</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;&#60;?php


?&#62;
</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
   </P
></DIV
><DIV
CLASS="section"
><HR><H2
CLASS="section"
><A
NAME="pear-options"
>Optional PHP Features</A
></H2
><P
>&#13;    PEAR code should be useable with all (reasonable) configurations
    of PHP.  Since PHP is very configurable and many of its features
    are optional, this requires extra attention from you as a PEAR
    author to make sure that your code works with different
    configurations.
   </P
><P
>&#13;    One example is the <TT
CLASS="parameter"
><I
>magic_quotes_gpc</I
></TT
> config
    option.  PEAR code should work with this option enabled or
    disabled.  Here's an example of how to properly do that:
    <DIV
CLASS="informalexample"
><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;// If magic_quotes_gpc is enabled, remove those slashes.
if (ini_get("magic_quotes_gpc")) {
    $arg = stripslashes($arg);
}
</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
   </P
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="pear-phptags"
>PHP Code Block Tags</A
></H3
><P
>&#13;     Always use the <B
CLASS="command"
>&#60;?php ?&#62;</B
> syntax, the
     shorter forms such as <B
CLASS="command"
>&#60;? ?&#62;</B
> and
     <B
CLASS="command"
>&#60;% %&#62;</B
> may be disabled by the user.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="pear-gpcvars"
>HTTP_*_VARS</A
></H3
><P
>&#13;     GET/POST/cookie can be configured to not be set in the global
     namespace, so PEAR code reading these should always use the
     global arrays <TT
CLASS="varname"
>$HTTP_GET_VARS</TT
>,
     <TT
CLASS="varname"
>$HTTP_POST_VARS</TT
>,
     <TT
CLASS="varname"
>$HTTP_COOKIE_VARS</TT
>,
     <TT
CLASS="varname"
>$HTTP_SERVER_VARS</TT
>,
     <TT
CLASS="varname"
>$HTTP_ENV_VARS</TT
> and
     <TT
CLASS="varname"
>$HTTP_POST_FILES</TT
> rather than the global
     variables.
    </P
></DIV
><DIV
CLASS="section"
><HR><H3
CLASS="section"
><A
NAME="pear-scope"
>Scope Issues</A
></H3
><P
>&#13;     If you need to set some global variables in the top-level part of
     your code (outside classes and functions), it is necessary to use
     <TT
CLASS="varname"
>$GLOBALS</TT
> to make sure your variable is
     actually set in the global scope regardless of where your file is
     included from.
    </P
><P
>&#13;     It is possible, and often very useful, to include a file from
     within a function.  The included file will inherit the calling
     code's scope:

     <TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
CLASS="EXAMPLE"
><TR
><TD
><DIV
CLASS="example"
><P
><B
>Example 3. file1.php</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;&#60;?php $myglobal = 42; ?&#62;
</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>

     <TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
CLASS="EXAMPLE"
><TR
><TD
><DIV
CLASS="example"
><P
><B
>Example 4. file2.php</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;&#60;?php

class Foo {
    function Foo($arg) {
        if ($arg == 42) {
            include("file1.php");
        }
    }
}

?&#62;
</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
><P
>&#13;     This actually sets <TT
CLASS="varname"
>$myglobal</TT
> as a local
     variable in the <TT
CLASS="classname"
>Foo</TT
> class's constructor
     function, not as a global variable.
    </P
><P
>&#13;     The correct/portable way to do this in
     <TT
CLASS="filename"
>file1.php</TT
> is:
     <TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
CLASS="EXAMPLE"
><TR
><TD
><DIV
CLASS="example"
><P
><B
>Example 5. Correct file1.php</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;&#60;?php $GLOBALS['myglobal'] = 42; ?&#62;
</PRE
></TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
>
    </P
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>